### Упражнение 1.23.

Процедура `smallest-divisor` в начале этого раздела проводит множество лишних проверок: после того, как она проверяет, делится ли число на 2, нет никакого смысла проверять делимость на другие четные числа. Таким образом, вместо последовательности `2, 3, 4, 5, 6 ...`, используемой для `test-divisor`, было бы лучше использовать `2, 3, 5, 7, 9 ...`. Чтобы реализовать такое улучшение, напишите процедуру `next`, которая имеет результатом `3`, если получает `2` как аргумент, а иначе возвращает свой аргумент плюс `2`. Используйте `(next test-divisor)` вместо `(+ test-divisor 1)` в `smallest-divisor`. Используя процедуру `timed-prime-test` с модифицированной версией `smallest-divisor`, запустите тест для каждого из `12` простых чисел, найденных в упражнении `1.22`. Поскольку эта модификация снижает количество шагов проверки вдвое, Вы должны ожидать двукратного ускорения проверки. Подтверждаются ли эти ожидания? Если нет, то каково наблюдаемое соотношение скоростей двух алгоритмов, и как Вы объясните то, что оно отличается от `2`?

```scheme
  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))
 
  (define (divides? a b)
    (= (remainder b a) 0))
```

### Решение

Не смог запустить (`*** ERROR: unbound variable: runtime`) 

[решение из другого источника](http://sicp.sergeykhenkin.com/2007/10/10/sicp-exercise-solution-1-23/)

```scheme
  (define (next n)
    (if (= n 2)
      3
      (+ n 2)))
```


